
    //let interval = Duration::from_secs(CHECK_EVERY.try_into().unwrap());
    //let mut next_time = Instant::now() + interval;
    //loop {

                        //let naive_str = naive.to_string();
                //let dt = "%Y-%m-%d %H:%M:%S")
                //let now_parsed = NaiveDateTime::parse_from_str(&naive, "%Y-%m-%d%H:%M:%S%f");
                //let formatted: String = now.to_rfc3339_opts(chrono::SecondsFormat::Secs, true);

                //println!("{:?} is parsed due: {:?}", task.description(), parsed.unwrap());
                //println!("Time now: {:?}", naive_parsed.unwrap());
                //assert_eq!(parsed.unwrap(), naive_parsed.unwrap());

                            //println!("Task name: {:?}", task.description())
        //println!("{:?}", pending_tasks[0]);
        //let imported = task_hookrs::import::import_tasks(data.as_bytes());
        //println!("{:?}", imported);


                //sleep(next_time - Instant::now());
        //next_time += interval;
    //}

                       
                    /*let dur = chrono::Duration::days(1);
                    if difference > dur {
                        println!("task is still coming up!");
                    } else {
                        println!("task has already passed!");
                    }*/
            
        //println!("{:?}", pending_tasks[0]);
        //let imported = task_hookrs::import::import_tasks(data.as_bytes());
        //println!("{:?}", imported);

        //use std::thread::sleep;
//use std::time::{Duration, Instant};


//use ntfy::payload::{Action, ActionType};


/*
        let mut task = std::process::Command::new("task");

        task.arg("rc.json.array=on")
                .arg("rc.confirmation=off")
                .arg("rc.json.depends.array=on")
                .arg("rc.color=off")
                .arg("rc._forcecolor=off")
                .arg("status:pending");
        task.arg("export");
    
    

        if let Ok(output) = task.output() {
            let data = String::from_utf8_lossy(&output.stdout);
            let pending_tasks: Tasks = serde_json::from_str(&data).unwrap();
            for task in pending_tasks {
                if let Some(_i) = task.due() {
                    println!("Task due: {:?}", task.due().unwrap());
                    let due = task.due().unwrap().to_string();
                    let now: DateTime<Local> = Local::now();

                
                    let parsed = NaiveDateTime::parse_from_str(&due, "%Y-%m-%d%H:%M:%S");

                    let naive = now.naive_local().to_string();
                    let naive_parsed = NaiveDateTime::parse_from_str(&naive, "%Y-%m-%d%H:%M:%S%.f");

                    let difference = parsed.unwrap() - naive_parsed.unwrap();
                    println!("'{}' is due in this many hours: {:?}", task.description(), difference.num_hours());
                    if difference.num_hours() < HOURS && difference.num_hours() > 0 {
                        println!("Send notification!!");
                    } else {
                        println!("Don't send notification!!");
                    }

                    let dur = chrono::Duration::days(1);
                    if difference > dur {
                        println!("task is still coming up!");
                    } else {
                        println!("task has already passed!");
                    }
               }
            }

        }
*/